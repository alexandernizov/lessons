1) Необходимо реализовать функцию для запуска конкуррентного пайплайна, состоящего из стейджей.

Стейдж - функция, принимающая канал на чтение и отдающая канал на чтение, внутри в горутине берущая данные из входного канала, выполняющая полезную работу и отдающая результат в выходной канал:

func Stage(in <-chan interface{}) (out <-chan interface{}) {
    out = make(chan interface{})
    go func() { /* Some work */ }()
    return out
}
Особенность пайплайна в том, что обработка последующего элемента входных данных должна происходить без ожидания завершения всего пайплайна для текущего элемента.

Т.е. пайплан из 4 функций по 100 мс каждая для 5 входных элементов должен выполняться гораздо быстрее, чем за 2 секунды (4 * 100 мс * 5).

Также должна быть реализована возможность остановить пайплайн через дополнительный сигнальный канал (done/terminate/etc.).

При необходимости можно выделять дополнительные функции.

Нельзя менять сигнатуры исходных функций.

Учесть, что в функции stage может случиться паника.

type (
 In  = <-chan interface{}
 Out = In
 Bi  = chan interface{}
)

type Stage func(in In) (out Out)

func ExecutePipeline(in In, done In, stages ...Stage) Out {
 // Place your code here.
 return nil
}
