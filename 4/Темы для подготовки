Map. Внутреннее устройство Map.
    Map - хэш таблица, - это структура данных, которая позволяет хранить данные ключ-значение. Ключом может быть любой тип, 
    кроме слайсов и функций, а значением — вообще любой тип. Оgoбладает следующими функциями:
        Инициализация:
            make(map[interface{}]interface{}) <- хорошо
            new(map[interface{}]interface{}) <- получим ссылку на nil
            var m map[key_type]value_type <- плохо, получим не инициализированную мапу
            m := map[interface{}]interface{} <- хорошо

        Маппинг (достать по ключу значение)
            m[key]
        Вставка
            m[key] = value
        Удаление
            delete(map, key)
        Поиск
            value, ok = m[key]

    Значения в map лежат неупорядоченно. Под капотом разработчики даже специально оставили функцию рандома, с которого места начинается
    поиск, чтобы не надеятся на то, что значения лежат упорядоченно:
        func mapiterinit(t *maptype, h *hmap, it *hiter) {...
        // decide where to start 
        r := uintptr(fastrand())
        ... 
        it.startBucket = r & bucketMask(h.B)...}
    
    При получении значения из map, по ключу, которого нет - возвращается zero value
    Пример:
        m := map[int]int{0: 0, 1: 10}
        m[0] // = 0
        m[1] // = 10
        m[2] // = 0
    Поэтому используем второе значение
        v, ok = m[2] // 0, false
    

Устройство памяти, процесс эвакуации
    Мапа в себе содержит:
        Количество ячеек
        Количество корзин (логарифм, чтобы быстрее считалось), LOB - low order bit
        Хэшсид, которое будет считывать хэш для значений
        указатель на корзины
        указатель на старые корзины

    Корзина в себе содержит:
        HOB - hier order bit - поля с заголовками хэша ключей - для, того, чтобы быстро сравнивать
        8 пар ключ-значение, которые размещены в памяти равномерно
    
    Когда количество ключей в корзине переполняется до значения 6,5 в среднем по всем корзинам в мапе - то происходит аллокация памяти
    создается в два раза больше корзин. Почему 6,5 - потому что от разработчика есть расчеты в src\runtime\map.go LoadFactor

    При аллокации памяти для новых корзин не происходит копирование данных из старых корзин в новые. Это происходит при записи или
    считывании конкретного значения.

    Кратко процесс записи в мапу:
        1. Взяли ключ, посчитали от него хэш
        2. Поделили хэш на количество корзин, получили остаток - именно в номер этой корзины мы должны записать значение
        3. В корзину записали: ХЭШ, Ключ, Значение
    
    Когда мы ищем значение:
        1. Взяли ключ, посчитали от него хэш
        2. По остатку от деления хэша на кол-во корзин узнали в какой корзине искать
        3. Проверили, что старшие биты хэша совпадают (если нет - то дальне не ищем)
        4. Если нашли совпадение - смотрим точное сравнение через equal

Коллизии, алгоритмы разрешения коллизий.
    Так как map - это ХЭШ таблица. А ХЭШ - это функция, которая нам возвращает какое-то вычисленное число для значения. То существует
    множество алгоритмов хэширования, хорошая хэш функция:
        1. Работает быстро
        2. Для разных значений возвращает разные хэш суммы
        3. Для одного и того же значения возвращает одну и ту же хэш сумму
        4. Равномерно распределяет хэшируемые значения
        Как всегда надо выбрать 3 из 4 или 2 из 4.
    Коллизия - это когда для разных значений мы получаем одну и ту же хэш сумму. Иначе говоря, имея на руках только хэш, мы не можем
    заранее сказать, что это в итоге за значение.
    Чтобы снизить количество коллизий, нам необходимо усложнить алгоритм хэширования и заплатить за этой скоростью работы.

    Для разрешения коллизий существуют алгоритмы. То есть - мы принимаем, что коллизии у нас могут быть и никуда от этого не деться.
    Но если такое случается, мы с этим будем как-то бороться, а именно разрешать коллизии, и у нас есть несколько подходов:
        1. Метод цепочек: когда мы храним не значение, а список значений:
            1. Посчитали хэш функцию для значения, нашли адрес, где хранятся значения по данному хэшу, и записали значение следующим образом:
                Значение
                Ссылка на следующее значение
                Если ссылки на следующее значение нет - то полученное значение это то, что нам нужно
        2. Линейное хэширование \ двойное хэширование
            1. Считаем для значения ХЭШ, если для данное значение уже захэшировано, то считаем хэш по хэшу
            2. Для двойного - так же считаем хэш два раза, но уже по хэшу значения 1 и хэшу значения n-1 (предыдущего)

Многопоточная работа с map. Особенности работы с sync.Map

