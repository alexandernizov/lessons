Базовые типы данных. Zero-Value
	Простые
		int -> int8 int16 int32 int64 - обозначение это количество бит выделяемой памяти
		uint -> uint8 uint16 uint32 uint64
			По-умолчанию 0
		float -> float32 float64
			По-умолчанию 0.0

		Если мы пишем int или float без указания разрядности - то при компилировании программы, мы будем выбирать под какую систему компилируется программа, тем самым мы заранее не знаем, какой разрядности будет эта переменная, но при компиляции мы явно это укажем

		bool
			По-умолчанию false. Описан в builtin константами как 0!=0 = false 0==0 = true

		byte
			Алиас для uint8 - разрядность из названия (байт=8бит), может принимать значения от 0 до 255. Используется как соглашение, чтобы отличать символьные буквы от целочисленных значений uint8
			По-умолчанию 0

		rune
			Аналог байт, но уже идет соответствие rune=int32
			По-умолчанию 0

		iota - используется для создания констант и нумерования списков чего либо, представляет собой uint
			По-умолчанию 0

	Условно простые
		string - это set всех строк из 8бит байтов. Обычно, не необходимо представляет собой текст, закодированный в UTF-8. Может быть пустой, но не nil. Значение в строке не мутабл
			По-умолчанию ""

	Составные
		interface{}
			Определяет методы, которые должны быть у другого типа. Реализация неявная, никаких ключевых слов у интерфейса нет: если у структуры не будет метода, который описан в интерфейсе - то будет ошибка на этапе компиляции. Может быть пустым (алиас any). Пустой интерфейс используется:
			По-умолчанию nil

		struct{}
			В основе своей структура - состоит из стандартных типов данных или других структур, но может использоваться и пустая структура, так как не весит ничего
			По-умолчанию nil

		массивы
		слайсы

		map[int]int

Указатели
	Указатели - это то, что хранит в себе ссылку на адрес памяти переменной, где она хранится. Например, у нас есть переменная int8, для неё выделена память в 1 байт, если мы хотим взять адрес памяти этой переменной, то нам надо взять &int8. А ещё у нас есть переменная АДРЕСА *int8 (со звездочкой). Ещё раз - у нас нет самого значения, но есть адрес переменной:
			//Есть переменная со значением 1
			var a int32
			a = 1
			//Есть переменная, которая содержит адрес на int32 (любой)
			var b *int32
			//Тут мы запомнили адрес от переменной а
			b = &a
			//Тут по адресу, который у нас был записан в b - взяли и прямо в память записали другое значение
			*b = 2
			//Поэтому в строчке ниже - мы получим 2 - ведь по адресу хранится уже 2
			fmt.Println(a)


Пакет builtin. Операции new / make.
	Это операции аллокации памяти в go.
	New - выделяем область в памяти, инициализирует zero value типом, и возвращает указатель на переменную.
		a := new(int)

		value := 0
		var b *int
		b = &value

		fmt.Println(a)
		fmt.Println(b)

		fmt.Println(*a)
		fmt.Println(*b)
	
	Make используется для создания каналов\срезов\карт. Так как каналы, мапы и слайсы - ссылочные типы, нам необходимо их мало того, что создать, но ещё и проинициализировать. Именно это и делает make - создаёт канал, и инициализириует его пустым значением

		var a map[string]string
		fmt.Println(a)
		b := make(map[string]string)
		fmt.Println(b)
		a["asd"] = "dsa" // без этой строчки код запустится без ошибок, но проблема именно в том, что ссылку на область памяти мы имеем, а самой памяти для записи значений мы не имеем, получим ошибку assigment to entry in nil map
		b["qwe"] = "ewq"

Выравнивание структур.
	Машинное слово - это единица данных, которая выбрана естественной для архитектуры процессора. Количество бит - размер слова. Большинство регистров в процессоре обычно имеют размер равный размеру машинного слова. И наибольшая часть данных, которая может быть передана в память процессора за одну операцию - это машинное слово. Для памяти есть определение - аппаратное слово.

	Для, того, чтобы процессору обработать данные в структуре - ему необходима память. И если мы уложим "кирпичики" рядом int32\int32\int64 - то получится так, что вся память у нас используется целесообразно - 4байта+4байта = 1 слово, 8 байт = ещё 1 слово = 2 слова. А если в разнобой int32\int64\int32- то получится так, что, используется 3 отдельных слова под отдельные переменные

	Подробнее тут: https://nuancesprog.ru/p/11674/

	Есть инструменты для помогают находить места для выравнивания структур - aligncheck, maligned


Пустой интерфейс и пустая структура
	Интерфейс:
		1. Передача в функцию, чтобы затем в самой функции определить тип полученных данных
		2. Поле структуры с пустым интерфейсом
		3. Для проверки типа данных

	Структуры:
		1. Передача в канал какого-то события, когда нам не важно само значение, а сам факт этого события
		2. Использование в map - когда нам нужны ключи, но не нужны значения
		3. Можно сделать type alias для пустых структур. Тем самым получаем именованное событие, которое не имеет никакого значения. Используется для того, чтобы передавать факт наличия. Пример: использование в контексте, когда мы хотим сохранить какое-то значение в контексте, мы сначала должны описать имя для этого значения, которое мы потом достанем
		4. Добавить пустую структуру в свою структуру, не задавая этому полю какое-либо имя. Нужно, чтобы предотвратить копирование структур

Структуры. Pointer receiver. Value receiver.
	Хорошее обьяснение здесь:
	https://habr.com/ru/articles/469859/

Escape Analysis. Стек и куча.
	Цикл статей: https://habr.com/ru/articles/497994/

	Надо запомнить: & - амперсанд - соедует читать как "Общий доступ", например:
		func main() {
			CreateUser()
			...
		}
		func CreateUser() *user {
			u := user{} <- мы создали новую переменную CreateUser, которая локально хранится в функции CreateUser (на самом деле в куче)
			return &u <- говорит, нам о том, что мы с main поделились адресом памяти на эту переменную
		} 
	go build -gcflags "-m -m" - выведет решения компилятора где хранить значение - в куче или в стэке